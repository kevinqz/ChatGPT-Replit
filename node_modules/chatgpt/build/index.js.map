{"version":3,"sources":["../src/chatgpt-api.ts","../src/types.ts","../src/abstract-chatgpt-api.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/stream-async-iterable.ts","../src/utils.ts","../src/chatgpt-api-browser.ts","../src/openai-auth.ts"],"sourcesContent":["import ExpiryMap from 'expiry-map'\nimport pTimeout from 'p-timeout'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as types from './types'\nimport { AChatGPTAPI } from './abstract-chatgpt-api'\nimport { fetch } from './fetch'\nimport { fetchSSE } from './fetch-sse'\nimport { markdownToText } from './utils'\n\nconst KEY_ACCESS_TOKEN = 'accessToken'\nconst USER_AGENT =\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'\n\nexport class ChatGPTAPI extends AChatGPTAPI {\n  protected _sessionToken: string\n  protected _clearanceToken: string\n  protected _markdown: boolean\n  protected _debug: boolean\n  protected _apiBaseUrl: string\n  protected _backendApiBaseUrl: string\n  protected _userAgent: string\n  protected _headers: Record<string, string>\n  protected _user: types.User | null = null\n\n  // Stores access tokens for `accessTokenTTL` milliseconds before needing to refresh\n  protected _accessTokenCache: ExpiryMap<string, string>\n\n  /**\n   * Creates a new client wrapper around the unofficial ChatGPT REST API.\n   *\n   * Note that your IP address and `userAgent` must match the same values that you used\n   * to obtain your `clearanceToken`.\n   *\n   * @param opts.sessionToken = **Required** OpenAI session token which can be found in a valid session's cookies (see readme for instructions)\n   * @param opts.clearanceToken = **Required** Cloudflare `cf_clearance` cookie value (see readme for instructions)\n   * @param apiBaseUrl - Optional override; the base URL for ChatGPT webapp's API (`/api`)\n   * @param backendApiBaseUrl - Optional override; the base URL for the ChatGPT backend API (`/backend-api`)\n   * @param userAgent - Optional override; the `user-agent` header to use with ChatGPT requests\n   * @param accessTokenTTL - Optional override; how long in milliseconds access tokens should last before being forcefully refreshed\n   * @param accessToken - Optional default access token if you already have a valid one generated\n   * @param heaaders - Optional additional HTTP headers to be added to each `fetch` request\n   * @param debug - Optional enables logging debugging into to stdout\n   */\n  constructor(opts: {\n    sessionToken: string\n\n    clearanceToken: string\n\n    /** @defaultValue `true` **/\n    markdown?: boolean\n\n    /** @defaultValue `'https://chat.openai.com/api'` **/\n    apiBaseUrl?: string\n\n    /** @defaultValue `'https://chat.openai.com/backend-api'` **/\n    backendApiBaseUrl?: string\n\n    /** @defaultValue `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'` **/\n    userAgent?: string\n\n    /** @defaultValue 1 hour **/\n    accessTokenTTL?: number\n\n    /** @defaultValue `undefined` **/\n    accessToken?: string\n\n    /** @defaultValue `undefined` **/\n    headers?: Record<string, string>\n\n    /** @defaultValue `false` **/\n    debug?: boolean\n  }) {\n    super()\n\n    const {\n      sessionToken,\n      clearanceToken,\n      markdown = true,\n      apiBaseUrl = 'https://chat.openai.com/api',\n      backendApiBaseUrl = 'https://chat.openai.com/backend-api',\n      userAgent = USER_AGENT,\n      accessTokenTTL = 60 * 60000, // 1 hour\n      accessToken,\n      headers,\n      debug = false\n    } = opts\n\n    this._sessionToken = sessionToken\n    this._clearanceToken = clearanceToken\n    this._markdown = !!markdown\n    this._debug = !!debug\n    this._apiBaseUrl = apiBaseUrl\n    this._backendApiBaseUrl = backendApiBaseUrl\n    this._userAgent = userAgent\n    this._headers = {\n      'user-agent': this._userAgent,\n      'x-openai-assistant-app-id': '',\n      'accept-language': 'en-US,en;q=0.9',\n      'accept-encoding': 'gzip, deflate, br',\n      origin: 'https://chat.openai.com',\n      referer: 'https://chat.openai.com/chat',\n      'sec-ch-ua':\n        '\"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\", \"Google Chrome\";v=\"108\"',\n      'sec-ch-ua-platform': '\"macOS\"',\n      'sec-fetch-dest': 'empty',\n      'sec-fetch-mode': 'cors',\n      'sec-fetch-site': 'same-origin',\n      ...headers\n    }\n\n    this._accessTokenCache = new ExpiryMap<string, string>(accessTokenTTL)\n    if (accessToken) {\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\n    }\n\n    if (!this._sessionToken) {\n      const error = new types.ChatGPTError('ChatGPT invalid session token')\n      error.statusCode = 401\n      throw error\n    }\n\n    if (!this._clearanceToken) {\n      const error = new types.ChatGPTError('ChatGPT invalid clearance token')\n      error.statusCode = 401\n      throw error\n    }\n  }\n\n  /**\n   * Gets the currently signed-in user, if authenticated, `null` otherwise.\n   */\n  get user() {\n    return this._user\n  }\n\n  /** Gets the current session token. */\n  get sessionToken() {\n    return this._sessionToken\n  }\n\n  /** Gets the current Cloudflare clearance token (`cf_clearance` cookie value). */\n  get clearanceToken() {\n    return this._clearanceToken\n  }\n\n  /** Gets the current user agent. */\n  get userAgent() {\n    return this._userAgent\n  }\n\n  /**\n   * Refreshes the client's access token which will succeed only if the session\n   * is valid.\n   */\n  override async initSession() {\n    await this.refreshSession()\n  }\n\n  /**\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\n   * the response.\n   *\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\n   * If you want to receive the full response, including message and conversation IDs,\n   * you can use `opts.onConversationResponse` or use the `ChatGPTAPI.getConversation`\n   * helper.\n   *\n   * @param message - The prompt message to send\n   * @param opts.conversationId - Optional ID of a conversation to continue\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\n   * @param opts.action - Optional ChatGPT `action` (either `next` or `variant`)\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n   *\n   * @returns The response from ChatGPT\n   */\n  override async sendMessage(\n    message: string,\n    opts: types.SendMessageOptions = {}\n  ): Promise<types.ChatResponse> {\n    const {\n      conversationId,\n      parentMessageId = uuidv4(),\n      messageId = uuidv4(),\n      action = 'next',\n      timeoutMs,\n      onProgress\n    } = opts\n\n    let { abortSignal } = opts\n\n    let abortController: AbortController = null\n    if (timeoutMs && !abortSignal) {\n      abortController = new AbortController()\n      abortSignal = abortController.signal\n    }\n\n    const accessToken = await this.refreshSession()\n\n    const body: types.ConversationJSONBody = {\n      action,\n      messages: [\n        {\n          id: messageId,\n          role: 'user',\n          content: {\n            content_type: 'text',\n            parts: [message]\n          }\n        }\n      ],\n      model: 'text-davinci-002-render',\n      parent_message_id: parentMessageId\n    }\n\n    if (conversationId) {\n      body.conversation_id = conversationId\n    }\n\n    const result: types.ChatResponse = {\n      conversationId,\n      messageId,\n      response: ''\n    }\n\n    const responseP = new Promise<types.ChatResponse>((resolve, reject) => {\n      const url = `${this._backendApiBaseUrl}/conversation`\n      const headers = {\n        ...this._headers,\n        Authorization: `Bearer ${accessToken}`,\n        Accept: 'text/event-stream',\n        'Content-Type': 'application/json',\n        Cookie: `cf_clearance=${this._clearanceToken}`\n      }\n\n      if (this._debug) {\n        console.log('POST', url, { body, headers })\n      }\n\n      fetchSSE(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal: abortSignal,\n        onMessage: (data: string) => {\n          if (data === '[DONE]') {\n            return resolve(result)\n          }\n\n          try {\n            const convoResponseEvent: types.ConversationResponseEvent =\n              JSON.parse(data)\n            if (convoResponseEvent.conversation_id) {\n              result.conversationId = convoResponseEvent.conversation_id\n            }\n\n            if (convoResponseEvent.message?.id) {\n              result.messageId = convoResponseEvent.message.id\n            }\n\n            const message = convoResponseEvent.message\n            // console.log('event', JSON.stringify(convoResponseEvent, null, 2))\n\n            if (message) {\n              let text = message?.content?.parts?.[0]\n\n              if (text) {\n                if (!this._markdown) {\n                  text = markdownToText(text)\n                }\n\n                result.response = text\n\n                if (onProgress) {\n                  onProgress(result)\n                }\n              }\n            }\n          } catch (err) {\n            console.warn('fetchSSE onMessage unexpected error', err)\n            reject(err)\n          }\n        }\n      }).catch((err) => {\n        const errMessageL = err.toString().toLowerCase()\n\n        if (\n          result.response &&\n          (errMessageL === 'error: typeerror: terminated' ||\n            errMessageL === 'typeerror: terminated')\n        ) {\n          // OpenAI sometimes forcefully terminates the socket from their end before\n          // the HTTP request has resolved cleanly. In my testing, these cases tend to\n          // happen when OpenAI has already send the last `response`, so we can ignore\n          // the `fetch` error in this case.\n          return resolve(result)\n        } else {\n          return reject(err)\n        }\n      })\n    })\n\n    if (timeoutMs) {\n      if (abortController) {\n        // This will be called when a timeout occurs in order for us to forcibly\n        // ensure that the underlying HTTP request is aborted.\n        ;(responseP as any).cancel = () => {\n          abortController.abort()\n        }\n      }\n\n      return pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'ChatGPT timed out waiting for response'\n      })\n    } else {\n      return responseP\n    }\n  }\n\n  async sendModeration(input: string) {\n    const accessToken = await this.refreshSession()\n    const url = `${this._backendApiBaseUrl}/moderations`\n    const headers = {\n      ...this._headers,\n      Authorization: `Bearer ${accessToken}`,\n      Accept: '*/*',\n      'Content-Type': 'application/json',\n      Cookie: `cf_clearance=${this._clearanceToken}`\n    }\n\n    const body: types.ModerationsJSONBody = {\n      input,\n      model: 'text-moderation-playground'\n    }\n\n    if (this._debug) {\n      console.log('POST', url, headers, body)\n    }\n\n    const res = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body)\n    }).then((r) => {\n      if (!r.ok) {\n        const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\n        error.response = r\n        error.statusCode = r.status\n        error.statusText = r.statusText\n        throw error\n      }\n\n      return r.json() as any as types.ModerationsJSONResult\n    })\n\n    return res\n  }\n\n  /**\n   * @returns `true` if the client has a valid acces token or `false` if refreshing\n   * the token fails.\n   */\n  override async getIsAuthenticated() {\n    try {\n      void (await this.refreshSession())\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  /**\n   * Attempts to refresh the current access token using the ChatGPT\n   * `sessionToken` cookie.\n   *\n   * Access tokens will be cached for up to `accessTokenTTL` milliseconds to\n   * prevent refreshing access tokens too frequently.\n   *\n   * @returns A valid access token\n   * @throws An error if refreshing the access token fails.\n   */\n  override async refreshSession(): Promise<string> {\n    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN)\n    if (cachedAccessToken) {\n      return cachedAccessToken\n    }\n\n    let response: Response\n    try {\n      const url = `${this._apiBaseUrl}/auth/session`\n      const headers = {\n        ...this._headers,\n        cookie: `cf_clearance=${this._clearanceToken}; __Secure-next-auth.session-token=${this._sessionToken}`,\n        accept: '*/*'\n      }\n\n      if (this._debug) {\n        console.log('GET', url, headers)\n      }\n\n      const res = await fetch(url, {\n        headers\n      }).then((r) => {\n        response = r\n\n        if (!r.ok) {\n          const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\n          error.response = r\n          error.statusCode = r.status\n          error.statusText = r.statusText\n          throw error\n        }\n\n        return r.json() as any as types.SessionResult\n      })\n\n      const accessToken = res?.accessToken\n\n      if (!accessToken) {\n        const error = new types.ChatGPTError('Unauthorized')\n        error.response = response\n        error.statusCode = response?.status\n        error.statusText = response?.statusText\n        throw error\n      }\n\n      const appError = res?.error\n      if (appError) {\n        if (appError === 'RefreshAccessTokenError') {\n          const error = new types.ChatGPTError('session token may have expired')\n          error.response = response\n          error.statusCode = response?.status\n          error.statusText = response?.statusText\n          throw error\n        } else {\n          const error = new types.ChatGPTError(appError)\n          error.response = response\n          error.statusCode = response?.status\n          error.statusText = response?.statusText\n          throw error\n        }\n      }\n\n      if (res.user) {\n        this._user = res.user\n      }\n\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\n      return accessToken\n    } catch (err: any) {\n      if (this._debug) {\n        console.error(err)\n      }\n\n      const error = new types.ChatGPTError(\n        `ChatGPT failed to refresh auth token. ${err.toString()}`\n      )\n      error.response = response\n      error.statusCode = response?.status\n      error.statusText = response?.statusText\n      error.originalError = err\n      throw error\n    }\n  }\n\n  override async closeSession(): Promise<void> {\n    this._accessTokenCache.delete(KEY_ACCESS_TOKEN)\n  }\n}\n","export type ContentType = 'text'\n\nexport type Role = 'user' | 'assistant'\n\n/**\n * https://chat.openapi.com/api/auth/session\n */\nexport type SessionResult = {\n  /**\n   * Authenticated user\n   */\n  user: User\n\n  /**\n   * ISO date of the expiration date of the access token\n   */\n  expires: string\n\n  /**\n   * The access token\n   */\n  accessToken: string\n\n  /**\n   * If there was an error associated with this request\n   */\n  error?: string | null\n}\n\nexport type User = {\n  /**\n   * ID of the user\n   */\n  id: string\n\n  /**\n   * Name of the user\n   */\n  name: string\n\n  /**\n   * Email of the user\n   */\n  email?: string\n\n  /**\n   * Image of the user\n   */\n  image: string\n\n  /**\n   * Picture of the user\n   */\n  picture: string\n\n  /**\n   * Groups the user is in\n   */\n  groups: string[]\n\n  /**\n   * Features the user is in\n   */\n  features: string[]\n}\n\n/**\n * https://chat.openapi.com/backend-api/models\n */\nexport type ModelsResult = {\n  /**\n   * Array of models\n   */\n  models: Model[]\n}\n\nexport type Model = {\n  /**\n   * Name of the model\n   */\n  slug: string\n\n  /**\n   * Max tokens of the model\n   */\n  max_tokens: number\n\n  /**\n   * Whether or not the model is special\n   */\n  is_special: boolean\n}\n\n/**\n * https://chat.openapi.com/backend-api/moderations\n */\nexport type ModerationsJSONBody = {\n  /**\n   * Input for the moderation decision\n   */\n  input: string\n\n  /**\n   * The model to use in the decision\n   */\n  model: AvailableModerationModels\n}\n\nexport type AvailableModerationModels = 'text-moderation-playground'\n\n/**\n * https://chat.openapi.com/backend-api/moderations\n */\nexport type ModerationsJSONResult = {\n  /**\n   * Whether or not the input is flagged\n   */\n  flagged: boolean\n\n  /**\n   * Whether or not the input is blocked\n   */\n  blocked: boolean\n\n  /**\n   * The ID of the decision\n   */\n  moderation_id: string\n}\n\n/**\n * https://chat.openapi.com/backend-api/conversation\n */\nexport type ConversationJSONBody = {\n  /**\n   * The action to take\n   */\n  action: string\n\n  /**\n   * The ID of the conversation\n   */\n  conversation_id?: string\n\n  /**\n   * Prompts to provide\n   */\n  messages: Prompt[]\n\n  /**\n   * The model to use\n   */\n  model: string\n\n  /**\n   * The parent message ID\n   */\n  parent_message_id: string\n}\n\nexport type Prompt = {\n  /**\n   * The content of the prompt\n   */\n  content: PromptContent\n\n  /**\n   * The ID of the prompt\n   */\n  id: string\n\n  /**\n   * The role played in the prompt\n   */\n  role: Role\n}\n\nexport type PromptContent = {\n  /**\n   * The content type of the prompt\n   */\n  content_type: ContentType\n\n  /**\n   * The parts to the prompt\n   */\n  parts: string[]\n}\n\n/**\n * https://chat.openapi.com/backend-api/conversation/message_feedback\n */\nexport type MessageFeedbackJSONBody = {\n  /**\n   * The ID of the conversation\n   */\n  conversation_id: string\n\n  /**\n   * The message ID\n   */\n  message_id: string\n\n  /**\n   * The rating\n   */\n  rating: MessageFeedbackRating\n\n  /**\n   * Tags to give the rating\n   */\n  tags?: MessageFeedbackTags[]\n\n  /**\n   * The text to include\n   */\n  text?: string\n}\n\nexport type MessageFeedbackTags = 'harmful' | 'false' | 'not-helpful'\n\nexport type MessageFeedbackResult = {\n  /**\n   * The message ID\n   */\n  message_id: string\n\n  /**\n   * The ID of the conversation\n   */\n  conversation_id: string\n\n  /**\n   * The ID of the user\n   */\n  user_id: string\n\n  /**\n   * The rating\n   */\n  rating: MessageFeedbackRating\n\n  /**\n   * The text the server received, including tags\n   */\n  text?: string\n}\n\nexport type MessageFeedbackRating = 'thumbsUp' | 'thumbsDown'\n\nexport type ConversationResponseEvent = {\n  message?: Message\n  conversation_id?: string\n  error?: string | null\n}\n\nexport type Message = {\n  id: string\n  content: MessageContent\n  role: string\n  user: string | null\n  create_time: string | null\n  update_time: string | null\n  end_turn: null\n  weight: number\n  recipient: string\n  metadata: MessageMetadata\n}\n\nexport type MessageContent = {\n  content_type: string\n  parts: string[]\n}\n\nexport type MessageMetadata = any\nexport type MessageActionType = 'next' | 'variant'\n\nexport type SendMessageOptions = {\n  conversationId?: string\n  parentMessageId?: string\n  messageId?: string\n  action?: MessageActionType\n  timeoutMs?: number\n  onProgress?: (partialResponse: ChatResponse) => void\n  abortSignal?: AbortSignal\n}\n\nexport type SendConversationMessageOptions = Omit<\n  SendMessageOptions,\n  'conversationId' | 'parentMessageId'\n>\n\nexport class ChatGPTError extends Error {\n  statusCode?: number\n  statusText?: string\n  response?: Response\n  originalError?: Error\n}\n\nexport type ChatError = {\n  error: { message: string; statusCode?: number; statusText?: string }\n  conversationId?: string\n  messageId?: string\n}\n\nexport type ChatResponse = {\n  response: string\n  conversationId: string\n  messageId: string\n}\n","import * as types from './types'\n\nexport abstract class AChatGPTAPI {\n  /**\n   * Performs any async initialization work required to ensure that this API is\n   * properly authenticated.\n   *\n   * @throws An error if the session failed to initialize properly.\n   */\n  abstract initSession(): Promise<void>\n\n  /**\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\n   * the response.\n   *\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\n   *\n   * @param message - The prompt message to send\n   * @param opts.conversationId - Optional ID of a conversation to continue\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\n   * @param opts.action - Optional ChatGPT `action` (either `next` or `variant`)\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n   *\n   * @returns The response from ChatGPT, including `conversationId`, `messageId`, and\n   * the `response` text.\n   */\n  abstract sendMessage(\n    message: string,\n    opts?: types.SendMessageOptions\n  ): Promise<types.ChatResponse>\n\n  /**\n   * @returns `true` if the client is authenticated with a valid session or `false`\n   * otherwise.\n   */\n  abstract getIsAuthenticated(): Promise<boolean>\n\n  /**\n   * Refreshes the current ChatGPT session.\n   *\n   * Useful for bypassing 403 errors when Cloudflare clearance tokens expire.\n   *\n   * @returns Access credentials for the new session.\n   * @throws An error if it fails.\n   */\n  abstract refreshSession(): Promise<any>\n\n  /**\n   * Closes the current ChatGPT session and starts a new one.\n   *\n   * Useful for bypassing 401 errors when sessions expire.\n   *\n   * @returns Access credentials for the new session.\n   * @throws An error if it fails.\n   */\n  async resetSession(): Promise<any> {\n    await this.closeSession()\n    return this.initSession()\n  }\n\n  /**\n   * Closes the active session.\n   *\n   * @throws An error if it fails.\n   */\n  abstract closeSession(): Promise<void>\n}\n","/// <reference lib=\"dom\" />\n\n// Use `fetch` for node.js >= 18\n// Use `fetch` for all other environments, including browsers\nconst fetch = globalThis.fetch\n\nif (typeof fetch !== 'function') {\n  throw new Error(\n    'Invalid environment: global fetch not defined; `chatgpt` requires Node.js >= 18 at the moment due to Cloudflare protections'\n  )\n}\n\nexport { fetch }\n","import { createParser } from 'eventsource-parser'\n\nimport * as types from './types'\nimport { fetch } from './fetch'\nimport { streamAsyncIterable } from './stream-async-iterable'\n\nexport async function fetchSSE(\n  url: string,\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void }\n) {\n  const { onMessage, ...fetchOptions } = options\n  const res = await fetch(url, fetchOptions)\n  if (!res.ok) {\n    const msg = `ChatGPTAPI error ${res.status || res.statusText}`\n    const error = new types.ChatGPTError(msg)\n    error.statusCode = res.status\n    error.statusText = res.statusText\n    error.response = res\n    throw error\n  }\n\n  const parser = createParser((event) => {\n    if (event.type === 'event') {\n      onMessage(event.data)\n    }\n  })\n\n  if (!res.body.getReader) {\n    // Vercel polyfills `fetch` with `node-fetch`, which doesn't conform to\n    // web standards, so this is a workaround...\n    const body: NodeJS.ReadableStream = res.body as any\n\n    if (!body.on || !body.read) {\n      throw new types.ChatGPTError('unsupported \"fetch\" implementation')\n    }\n\n    body.on('readable', () => {\n      let chunk: string | Buffer\n      while (null !== (chunk = body.read())) {\n        parser.feed(chunk.toString())\n      }\n    })\n  } else {\n    for await (const chunk of streamAsyncIterable(res.body)) {\n      const str = new TextDecoder().decode(chunk)\n      parser.feed(str)\n    }\n  }\n}\n","export async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\n  const reader = stream.getReader()\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) {\n        return\n      }\n      yield value\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n","import type * as PTimeoutTypes from 'p-timeout'\nimport type {\n  EventSourceParseCallback,\n  EventSourceParser\n} from 'eventsource-parser'\nimport type { Page } from 'puppeteer'\nimport { remark } from 'remark'\nimport stripMarkdown from 'strip-markdown'\n\nimport * as types from './types'\n\nexport function markdownToText(markdown?: string): string {\n  return remark()\n    .use(stripMarkdown)\n    .processSync(markdown ?? '')\n    .toString()\n}\n\nexport async function minimizePage(page: Page) {\n  const session = await page.target().createCDPSession()\n  const goods = await session.send('Browser.getWindowForTarget')\n  const { windowId } = goods\n  await session.send('Browser.setWindowBounds', {\n    windowId,\n    bounds: { windowState: 'minimized' }\n  })\n}\n\nexport async function maximizePage(page: Page) {\n  const session = await page.target().createCDPSession()\n  const goods = await session.send('Browser.getWindowForTarget')\n  const { windowId } = goods\n  await session.send('Browser.setWindowBounds', {\n    windowId,\n    bounds: { windowState: 'normal' }\n  })\n}\n\nexport function isRelevantRequest(url: string): boolean {\n  let pathname: string\n\n  try {\n    const parsedUrl = new URL(url)\n    pathname = parsedUrl.pathname\n    url = parsedUrl.toString()\n  } catch (_) {\n    return false\n  }\n\n  if (!url.startsWith('https://chat.openai.com')) {\n    return false\n  }\n\n  if (\n    !pathname.startsWith('/backend-api/') &&\n    !pathname.startsWith('/api/auth/session')\n  ) {\n    return false\n  }\n\n  if (pathname.endsWith('backend-api/moderations')) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * This function is injected into the ChatGPT webapp page using puppeteer. It\n * has to be fully self-contained, so we copied a few third-party sources and\n * included them in here.\n */\nexport async function browserPostEventStream(\n  url: string,\n  accessToken: string,\n  body: types.ConversationJSONBody,\n  timeoutMs?: number\n): Promise<types.ChatError | types.ChatResponse> {\n  // Workaround for https://github.com/esbuild-kit/tsx/issues/113\n  globalThis.__name = () => undefined\n\n  class TimeoutError extends Error {\n    readonly name: 'TimeoutError'\n\n    constructor(message) {\n      super(message)\n      this.name = 'TimeoutError'\n    }\n  }\n\n  /**\n    An error to be thrown when the request is aborted by AbortController.\n    DOMException is thrown instead of this Error when DOMException is available.\n  */\n  class AbortError extends Error {\n    constructor(message) {\n      super()\n      this.name = 'AbortError'\n      this.message = message\n    }\n  }\n\n  const BOM = [239, 187, 191]\n\n  let conversationId: string = body?.conversation_id\n  let messageId: string = body?.messages?.[0]?.id\n  let response = ''\n\n  try {\n    console.log('browserPostEventStream', url, accessToken, body)\n\n    let abortController: AbortController = null\n    if (timeoutMs) {\n      abortController = new AbortController()\n    }\n\n    const res = await fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(body),\n      signal: abortController?.signal,\n      headers: {\n        accept: 'text/event-stream',\n        'x-openai-assistant-app-id': '',\n        authorization: `Bearer ${accessToken}`,\n        'content-type': 'application/json'\n      }\n    })\n\n    console.log('browserPostEventStream response', res)\n\n    if (!res.ok) {\n      return {\n        error: {\n          message: `ChatGPTAPI error ${res.status || res.statusText}`,\n          statusCode: res.status,\n          statusText: res.statusText\n        },\n        conversationId,\n        messageId\n      }\n    }\n\n    const responseP = new Promise<types.ChatResponse>(\n      async (resolve, reject) => {\n        function onMessage(data: string) {\n          if (data === '[DONE]') {\n            return resolve({\n              response,\n              conversationId,\n              messageId\n            })\n          }\n\n          try {\n            const convoResponseEvent: types.ConversationResponseEvent =\n              JSON.parse(data)\n            if (convoResponseEvent.conversation_id) {\n              conversationId = convoResponseEvent.conversation_id\n            }\n\n            if (convoResponseEvent.message?.id) {\n              messageId = convoResponseEvent.message.id\n            }\n\n            const partialResponse =\n              convoResponseEvent.message?.content?.parts?.[0]\n            if (partialResponse) {\n              response = partialResponse\n            }\n          } catch (err) {\n            console.warn('fetchSSE onMessage unexpected error', err)\n            reject(err)\n          }\n        }\n\n        const parser = createParser((event) => {\n          if (event.type === 'event') {\n            onMessage(event.data)\n          }\n        })\n\n        for await (const chunk of streamAsyncIterable(res.body)) {\n          const str = new TextDecoder().decode(chunk)\n          parser.feed(str)\n        }\n      }\n    )\n\n    if (timeoutMs) {\n      if (abortController) {\n        // This will be called when a timeout occurs in order for us to forcibly\n        // ensure that the underlying HTTP request is aborted.\n        ;(responseP as any).cancel = () => {\n          abortController.abort()\n        }\n      }\n\n      return await pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'ChatGPT timed out waiting for response'\n      })\n    } else {\n      return await responseP\n    }\n  } catch (err) {\n    const errMessageL = err.toString().toLowerCase()\n\n    if (\n      response &&\n      (errMessageL === 'error: typeerror: terminated' ||\n        errMessageL === 'typeerror: terminated')\n    ) {\n      // OpenAI sometimes forcefully terminates the socket from their end before\n      // the HTTP request has resolved cleanly. In my testing, these cases tend to\n      // happen when OpenAI has already send the last `response`, so we can ignore\n      // the `fetch` error in this case.\n      return {\n        response,\n        conversationId,\n        messageId\n      }\n    }\n\n    return {\n      error: {\n        message: err.toString(),\n        statusCode: err.statusCode || err.status || err.response?.statusCode,\n        statusText: err.statusText || err.response?.statusText\n      },\n      conversationId,\n      messageId\n    }\n  }\n\n  async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\n    const reader = stream.getReader()\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          return\n        }\n        yield value\n      }\n    } finally {\n      reader.releaseLock()\n    }\n  }\n\n  // @see https://github.com/rexxars/eventsource-parser\n  function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n    // Processing state\n    let isFirstChunk: boolean\n    let buffer: string\n    let startingPosition: number\n    let startingFieldLength: number\n\n    // Event state\n    let eventId: string | undefined\n    let eventName: string | undefined\n    let data: string\n\n    reset()\n    return { feed, reset }\n\n    function reset(): void {\n      isFirstChunk = true\n      buffer = ''\n      startingPosition = 0\n      startingFieldLength = -1\n\n      eventId = undefined\n      eventName = undefined\n      data = ''\n    }\n\n    function feed(chunk: string): void {\n      buffer = buffer ? buffer + chunk : chunk\n\n      // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n      // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n      // always decoded as UTF8 as per the specification.\n      if (isFirstChunk && hasBom(buffer)) {\n        buffer = buffer.slice(BOM.length)\n      }\n\n      isFirstChunk = false\n\n      // Set up chunk-specific processing state\n      const length = buffer.length\n      let position = 0\n      let discardTrailingNewline = false\n\n      // Read the current buffer byte by byte\n      while (position < length) {\n        // EventSource allows for carriage return + line feed, which means we\n        // need to ignore a linefeed character if the previous character was a\n        // carriage return\n        // @todo refactor to reduce nesting, consider checking previous byte?\n        // @todo but consider multiple chunks etc\n        if (discardTrailingNewline) {\n          if (buffer[position] === '\\n') {\n            ++position\n          }\n          discardTrailingNewline = false\n        }\n\n        let lineLength = -1\n        let fieldLength = startingFieldLength\n        let character: string\n\n        for (\n          let index = startingPosition;\n          lineLength < 0 && index < length;\n          ++index\n        ) {\n          character = buffer[index]\n          if (character === ':' && fieldLength < 0) {\n            fieldLength = index - position\n          } else if (character === '\\r') {\n            discardTrailingNewline = true\n            lineLength = index - position\n          } else if (character === '\\n') {\n            lineLength = index - position\n          }\n        }\n\n        if (lineLength < 0) {\n          startingPosition = length - position\n          startingFieldLength = fieldLength\n          break\n        } else {\n          startingPosition = 0\n          startingFieldLength = -1\n        }\n\n        parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n        position += lineLength + 1\n      }\n\n      if (position === length) {\n        // If we consumed the entire buffer to read the event, reset the buffer\n        buffer = ''\n      } else if (position > 0) {\n        // If there are bytes left to process, set the buffer to the unprocessed\n        // portion of the buffer only\n        buffer = buffer.slice(position)\n      }\n    }\n\n    function parseEventStreamLine(\n      lineBuffer: string,\n      index: number,\n      fieldLength: number,\n      lineLength: number\n    ) {\n      if (lineLength === 0) {\n        // We reached the last line of this event\n        if (data.length > 0) {\n          onParse({\n            type: 'event',\n            id: eventId,\n            event: eventName || undefined,\n            data: data.slice(0, -1) // remove trailing newline\n          })\n\n          data = ''\n          eventId = undefined\n        }\n        eventName = undefined\n        return\n      }\n\n      const noValue = fieldLength < 0\n      const field = lineBuffer.slice(\n        index,\n        index + (noValue ? lineLength : fieldLength)\n      )\n      let step = 0\n\n      if (noValue) {\n        step = lineLength\n      } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n        step = fieldLength + 2\n      } else {\n        step = fieldLength + 1\n      }\n\n      const position = index + step\n      const valueLength = lineLength - step\n      const value = lineBuffer\n        .slice(position, position + valueLength)\n        .toString()\n\n      if (field === 'data') {\n        data += value ? `${value}\\n` : '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id' && !value.includes('\\u0000')) {\n        eventId = value\n      } else if (field === 'retry') {\n        const retry = parseInt(value, 10)\n        if (!Number.isNaN(retry)) {\n          onParse({ type: 'reconnect-interval', value: retry })\n        }\n      }\n    }\n  }\n\n  function hasBom(buffer: string) {\n    return BOM.every(\n      (charCode: number, index: number) => buffer.charCodeAt(index) === charCode\n    )\n  }\n\n  /**\n    TODO: Remove AbortError and just throw DOMException when targeting Node 18.\n   */\n  function getDOMException(errorMessage) {\n    return globalThis.DOMException === undefined\n      ? new AbortError(errorMessage)\n      : new DOMException(errorMessage)\n  }\n\n  /**\n    TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n   */\n  function getAbortedReason(signal) {\n    const reason =\n      signal.reason === undefined\n        ? getDOMException('This operation was aborted.')\n        : signal.reason\n\n    return reason instanceof Error ? reason : getDOMException(reason)\n  }\n\n  // @see https://github.com/sindresorhus/p-timeout\n  function pTimeout<ValueType, ReturnType = ValueType>(\n    promise: PromiseLike<ValueType>,\n    options: PTimeoutTypes.Options<ReturnType>\n  ): PTimeoutTypes.ClearablePromise<ValueType | ReturnType> {\n    const {\n      milliseconds,\n      fallback,\n      message,\n      customTimers = { setTimeout, clearTimeout }\n    } = options\n\n    let timer: number\n\n    const cancelablePromise = new Promise((resolve, reject) => {\n      if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n        throw new TypeError(\n          `Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``\n        )\n      }\n\n      if (milliseconds === Number.POSITIVE_INFINITY) {\n        resolve(promise)\n        return\n      }\n\n      if (options.signal) {\n        const { signal } = options\n        if (signal.aborted) {\n          reject(getAbortedReason(signal))\n        }\n\n        signal.addEventListener('abort', () => {\n          reject(getAbortedReason(signal))\n        })\n      }\n\n      timer = customTimers.setTimeout.call(\n        undefined,\n        () => {\n          if (fallback) {\n            try {\n              resolve(fallback())\n            } catch (error) {\n              reject(error)\n            }\n\n            return\n          }\n\n          const errorMessage =\n            typeof message === 'string'\n              ? message\n              : `Promise timed out after ${milliseconds} milliseconds`\n          const timeoutError =\n            message instanceof Error ? message : new TimeoutError(errorMessage)\n\n          if (typeof (promise as any).cancel === 'function') {\n            ;(promise as any).cancel()\n          }\n\n          reject(timeoutError)\n        },\n        milliseconds\n      )\n      ;(async () => {\n        try {\n          resolve(await promise)\n        } catch (error) {\n          reject(error)\n        } finally {\n          customTimers.clearTimeout.call(undefined, timer)\n        }\n      })()\n    })\n\n    ;(cancelablePromise as any).clear = () => {\n      customTimers.clearTimeout.call(undefined, timer)\n      timer = undefined\n    }\n\n    return cancelablePromise as any\n  }\n}\n","import delay from 'delay'\nimport type { Browser, HTTPRequest, HTTPResponse, Page } from 'puppeteer'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as types from './types'\nimport { AChatGPTAPI } from './abstract-chatgpt-api'\nimport { getBrowser, getOpenAIAuth } from './openai-auth'\nimport {\n  browserPostEventStream,\n  isRelevantRequest,\n  markdownToText,\n  maximizePage,\n  minimizePage\n} from './utils'\n\nconst CHAT_PAGE_URL = 'https://chat.openai.com/chat'\n\nexport class ChatGPTAPIBrowser extends AChatGPTAPI {\n  protected _markdown: boolean\n  protected _debug: boolean\n  protected _minimize: boolean\n  protected _isGoogleLogin: boolean\n  protected _isMicrosoftLogin: boolean\n  protected _captchaToken: string\n  protected _accessToken: string\n\n  protected _email: string\n  protected _password: string\n\n  protected _executablePath: string\n  protected _browser: Browser\n  protected _page: Page\n  protected _proxyServer: string\n\n  /**\n   * Creates a new client for automating the ChatGPT webapp.\n   */\n  constructor(opts: {\n    email: string\n    password: string\n\n    /** @defaultValue `true` **/\n    markdown?: boolean\n\n    /** @defaultValue `false` **/\n    debug?: boolean\n\n    /** @defaultValue `false` **/\n    isGoogleLogin?: boolean\n\n    /** @defaultValue `false` **/\n    isMicrosoftLogin?: boolean\n\n    /** @defaultValue `true` **/\n    minimize?: boolean\n\n    /** @defaultValue `undefined` **/\n    captchaToken?: string\n\n    /** @defaultValue `undefined` **/\n    executablePath?: string\n\n    /** @defaultValue `undefined` **/\n    proxyServer?: string\n  }) {\n    super()\n\n    const {\n      email,\n      password,\n      markdown = true,\n      debug = false,\n      isGoogleLogin = false,\n      isMicrosoftLogin = false,\n      minimize = true,\n      captchaToken,\n      executablePath,\n      proxyServer\n    } = opts\n\n    this._email = email\n    this._password = password\n\n    this._markdown = !!markdown\n    this._debug = !!debug\n    this._isGoogleLogin = !!isGoogleLogin\n    this._isMicrosoftLogin = !!isMicrosoftLogin\n    this._minimize = !!minimize\n    this._captchaToken = captchaToken\n    this._executablePath = executablePath\n    this._proxyServer = proxyServer\n\n    if (!this._email) {\n      const error = new types.ChatGPTError('ChatGPT invalid email')\n      error.statusCode = 401\n      throw error\n    }\n\n    if (!this._password) {\n      const error = new types.ChatGPTError('ChatGPT invalid password')\n      error.statusCode = 401\n      throw error\n    }\n  }\n\n  override async initSession() {\n    if (this._browser) {\n      await this.closeSession()\n    }\n\n    try {\n      this._browser = await getBrowser({\n        captchaToken: this._captchaToken,\n        executablePath: this._executablePath,\n        proxyServer: this._proxyServer\n      })\n      this._page =\n        (await this._browser.pages())[0] || (await this._browser.newPage())\n\n      // bypass annoying popup modals\n      this._page.evaluateOnNewDocument(() => {\n        window.localStorage.setItem('oai/apps/hasSeenOnboarding/chat', 'true')\n        window.localStorage.setItem(\n          'oai/apps/hasSeenReleaseAnnouncement/2022-12-15',\n          'true'\n        )\n      })\n\n      await maximizePage(this._page)\n\n      this._page.on('request', this._onRequest.bind(this))\n      this._page.on('response', this._onResponse.bind(this))\n\n      // bypass cloudflare and login\n      await getOpenAIAuth({\n        email: this._email,\n        password: this._password,\n        browser: this._browser,\n        page: this._page,\n        isGoogleLogin: this._isGoogleLogin,\n        isMicrosoftLogin: this._isMicrosoftLogin\n      })\n    } catch (err) {\n      if (this._browser) {\n        await this._browser.close()\n      }\n\n      this._browser = null\n      this._page = null\n\n      throw err\n    }\n\n    if (!this.isChatPage || this._isGoogleLogin || this._isMicrosoftLogin) {\n      await this._page.goto(CHAT_PAGE_URL, {\n        waitUntil: 'networkidle2'\n      })\n    }\n\n    // dismiss welcome modal (and other modals)\n    do {\n      const modalSelector = '[data-headlessui-state=\"open\"]'\n\n      try {\n        if (!(await this._page.$(modalSelector))) {\n          break\n        }\n\n        await this._page.click(`${modalSelector} button:last-child`)\n      } catch (err) {\n        // \"next\" button not found in welcome modal\n        break\n      }\n\n      await delay(300)\n    } while (true)\n\n    if (!(await this.getIsAuthenticated())) {\n      throw new types.ChatGPTError('Failed to authenticate session')\n    }\n\n    if (this._minimize) {\n      return minimizePage(this._page)\n    }\n  }\n\n  _onRequest = (request: HTTPRequest) => {\n    const url = request.url()\n    if (!isRelevantRequest(url)) {\n      return\n    }\n\n    const method = request.method()\n    let body: any\n\n    if (method === 'POST') {\n      body = request.postData()\n\n      try {\n        body = JSON.parse(body)\n      } catch (_) {}\n\n      // if (url.endsWith('/conversation') && typeof body === 'object') {\n      //   const conversationBody: types.ConversationJSONBody = body\n      //   const conversationId = conversationBody.conversation_id\n      //   const parentMessageId = conversationBody.parent_message_id\n      //   const messageId = conversationBody.messages?.[0]?.id\n      //   const prompt = conversationBody.messages?.[0]?.content?.parts?.[0]\n\n      //   // TODO: store this info for the current sendMessage request\n      // }\n    }\n\n    if (this._debug) {\n      console.log('\\nrequest', {\n        url,\n        method,\n        headers: request.headers(),\n        body\n      })\n    }\n  }\n\n  _onResponse = async (response: HTTPResponse) => {\n    const request = response.request()\n\n    const url = response.url()\n    if (!isRelevantRequest(url)) {\n      return\n    }\n\n    const status = response.status()\n\n    let body: any\n    try {\n      body = await response.json()\n    } catch (_) {}\n\n    if (this._debug) {\n      console.log('\\nresponse', {\n        url,\n        ok: response.ok(),\n        status,\n        statusText: response.statusText(),\n        headers: response.headers(),\n        body,\n        request: {\n          method: request.method(),\n          headers: request.headers(),\n          body: request.postData()\n        }\n      })\n    }\n\n    if (url.endsWith('/conversation')) {\n      if (status === 403) {\n        await this.refreshSession()\n      }\n    } else if (url.endsWith('api/auth/session')) {\n      if (status === 401) {\n        await this.resetSession()\n      } else if (status === 403) {\n        await this.refreshSession()\n      } else {\n        const session: types.SessionResult = body\n\n        if (session?.accessToken) {\n          this._accessToken = session.accessToken\n        }\n      }\n    }\n  }\n\n  /**\n   * Attempts to handle 401 errors by re-authenticating.\n   */\n  async resetSession() {\n    console.log(\n      `ChatGPT \"${this._email}\" session expired; re-authenticating...`\n    )\n    try {\n      await this.closeSession()\n      await this.initSession()\n      console.log(`ChatGPT \"${this._email}\" re-authenticated successfully`)\n    } catch (err) {\n      console.error(\n        `ChatGPT \"${this._email}\" error re-authenticating`,\n        err.toString()\n      )\n    }\n  }\n\n  /**\n   * Attempts to handle 403 errors by refreshing the page.\n   */\n  async refreshSession() {\n    console.log(`ChatGPT \"${this._email}\" session expired (403); refreshing...`)\n    try {\n      if (!this._minimize) {\n        await maximizePage(this._page)\n      }\n      await this._page.reload({\n        waitUntil: 'networkidle2',\n        timeout: 2 * 60 * 1000 // 2 minutes\n      })\n      if (this._minimize && this.isChatPage) {\n        await minimizePage(this._page)\n      }\n      console.log(`ChatGPT \"${this._email}\" refreshed session successfully`)\n    } catch (err) {\n      console.error(\n        `ChatGPT \"${this._email}\" error refreshing session`,\n        err.toString()\n      )\n    }\n  }\n\n  async getIsAuthenticated() {\n    try {\n      if (!this._accessToken) {\n        return false\n      }\n\n      const inputBox = await this._getInputBox()\n      return !!inputBox\n    } catch (err) {\n      // can happen when navigating during login\n      return false\n    }\n  }\n\n  // async getLastMessage(): Promise<string | null> {\n  //   const messages = await this.getMessages()\n\n  //   if (messages) {\n  //     return messages[messages.length - 1]\n  //   } else {\n  //     return null\n  //   }\n  // }\n\n  // async getPrompts(): Promise<string[]> {\n  //   // Get all prompts\n  //   const messages = await this._page.$$(\n  //     '.text-base:has(.whitespace-pre-wrap):not(:has(button:nth-child(2))) .whitespace-pre-wrap'\n  //   )\n\n  //   // Prompts are always plaintext\n  //   return Promise.all(messages.map((a) => a.evaluate((el) => el.textContent)))\n  // }\n\n  // async getMessages(): Promise<string[]> {\n  //   // Get all complete messages\n  //   // (in-progress messages that are being streamed back don't contain action buttons)\n  //   const messages = await this._page.$$(\n  //     '.text-base:has(.whitespace-pre-wrap):has(button:nth-child(2)) .whitespace-pre-wrap'\n  //   )\n\n  //   if (this._markdown) {\n  //     const htmlMessages = await Promise.all(\n  //       messages.map((a) => a.evaluate((el) => el.innerHTML))\n  //     )\n\n  //     const markdownMessages = htmlMessages.map((messageHtml) => {\n  //       // parse markdown from message HTML\n  //       messageHtml = messageHtml\n  //         .replaceAll('Copy code</button>', '</button>')\n  //         .replace(/Copy code\\s*<\\/button>/gim, '</button>')\n\n  //       return html2md(messageHtml, {\n  //         ignoreTags: [\n  //           'button',\n  //           'svg',\n  //           'style',\n  //           'form',\n  //           'noscript',\n  //           'script',\n  //           'meta',\n  //           'head'\n  //         ],\n  //         skipTags: ['button', 'svg']\n  //       })\n  //     })\n\n  //     return markdownMessages\n  //   } else {\n  //     // plaintext\n  //     const plaintextMessages = await Promise.all(\n  //       messages.map((a) => a.evaluate((el) => el.textContent))\n  //     )\n  //     return plaintextMessages\n  //   }\n  // }\n\n  override async sendMessage(\n    message: string,\n    opts: types.SendMessageOptions = {}\n  ): Promise<types.ChatResponse> {\n    const {\n      conversationId,\n      parentMessageId = uuidv4(),\n      messageId = uuidv4(),\n      action = 'next',\n      timeoutMs\n      // TODO\n      // onProgress\n    } = opts\n\n    const url = `https://chat.openai.com/backend-api/conversation`\n    const body: types.ConversationJSONBody = {\n      action,\n      messages: [\n        {\n          id: messageId,\n          role: 'user',\n          content: {\n            content_type: 'text',\n            parts: [message]\n          }\n        }\n      ],\n      model: 'text-davinci-002-render',\n      parent_message_id: parentMessageId\n    }\n\n    if (conversationId) {\n      body.conversation_id = conversationId\n    }\n\n    let result: types.ChatResponse | types.ChatError\n    let numTries = 0\n\n    do {\n      if (!(await this.getIsAuthenticated())) {\n        console.log(`chatgpt re-authenticating ${this._email}`)\n\n        try {\n          await this.resetSession()\n        } catch (err) {\n          console.warn(\n            `chatgpt error re-authenticating ${this._email}`,\n            err.toString()\n          )\n        }\n\n        if (!(await this.getIsAuthenticated())) {\n          const error = new types.ChatGPTError('Not signed in')\n          error.statusCode = 401\n          throw error\n        }\n      }\n\n      try {\n        // console.log('>>> EVALUATE', url, this._accessToken, body)\n        result = await this._page.evaluate(\n          browserPostEventStream,\n          url,\n          this._accessToken,\n          body,\n          timeoutMs\n        )\n      } catch (err) {\n        // We catch all errors in `browserPostEventStream`, so this should really\n        // only happen if the page is refreshed or closed during its invocation.\n        // This may happen if we encounter a 401/403 and refresh the page in it's\n        // response handler or if the user has closed the page manually.\n\n        if (++numTries >= 2) {\n          const error = new types.ChatGPTError(err.toString())\n          error.statusCode = err.response?.statusCode\n          error.statusText = err.response?.statusText\n          throw error\n        }\n\n        console.warn('chatgpt sendMessage error; retrying...', err.toString())\n        await delay(5000)\n      }\n    } while (!result)\n\n    // console.log('<<< EVALUATE', result)\n\n    if ('error' in result) {\n      const error = new types.ChatGPTError(result.error.message)\n      error.statusCode = result.error.statusCode\n      error.statusText = result.error.statusText\n\n      if (error.statusCode === 403) {\n        await this.refreshSession()\n      }\n\n      throw error\n    } else {\n      if (!this._markdown) {\n        result.response = markdownToText(result.response)\n      }\n\n      return result\n    }\n\n    // const lastMessage = await this.getLastMessage()\n\n    // await inputBox.focus()\n    // const paragraphs = message.split('\\n')\n    // for (let i = 0; i < paragraphs.length; i++) {\n    //   await inputBox.type(paragraphs[i], { delay: 0 })\n    //   if (i < paragraphs.length - 1) {\n    //     await this._page.keyboard.down('Shift')\n    //     await inputBox.press('Enter')\n    //     await this._page.keyboard.up('Shift')\n    //   } else {\n    //     await inputBox.press('Enter')\n    //   }\n    // }\n\n    // const responseP = new Promise<string>(async (resolve, reject) => {\n    //   try {\n    //     do {\n    //       await delay(1000)\n\n    //       // TODO: this logic needs some work because we can have repeat messages...\n    //       const newLastMessage = await this.getLastMessage()\n    //       if (\n    //         newLastMessage &&\n    //         lastMessage?.toLowerCase() !== newLastMessage?.toLowerCase()\n    //       ) {\n    //         return resolve(newLastMessage)\n    //       }\n    //     } while (true)\n    //   } catch (err) {\n    //     return reject(err)\n    //   }\n    // })\n\n    // if (timeoutMs) {\n    //   return pTimeout(responseP, {\n    //     milliseconds: timeoutMs\n    //   })\n    // } else {\n    //   return responseP\n    // }\n  }\n\n  async resetThread() {\n    try {\n      await this._page.click('nav > a:nth-child(1)')\n    } catch (err) {\n      // ignore for now\n    }\n  }\n\n  override async closeSession() {\n    await this._browser.close()\n    this._page = null\n    this._browser = null\n    this._accessToken = null\n  }\n\n  protected async _getInputBox() {\n    try {\n      return await this._page.$('textarea')\n    } catch (err) {\n      return null\n    }\n  }\n\n  get isChatPage(): boolean {\n    try {\n      const url = this._page?.url().replace(/\\/$/, '')\n      return url === CHAT_PAGE_URL\n    } catch (err) {\n      return false\n    }\n  }\n}\n","import * as fs from 'node:fs'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\nimport * as url from 'node:url'\n\nimport delay from 'delay'\nimport { TimeoutError } from 'p-timeout'\nimport type { Browser, Page, Protocol, PuppeteerLaunchOptions } from 'puppeteer'\nimport puppeteer from 'puppeteer-extra'\nimport RecaptchaPlugin from 'puppeteer-extra-plugin-recaptcha'\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth'\nimport random from 'random'\n\nimport * as types from './types'\n\npuppeteer.use(StealthPlugin())\n\nlet hasRecaptchaPlugin = false\nlet hasNopechaExtension = false\n\nconst __dirname = url.fileURLToPath(new URL('.', import.meta.url))\n\n/**\n * Represents everything that's required to pass into `ChatGPTAPI` in order\n * to authenticate with the unofficial ChatGPT API.\n */\nexport type OpenAIAuth = {\n  userAgent: string\n  clearanceToken: string\n  sessionToken: string\n  cookies?: Record<string, Protocol.Network.Cookie>\n}\n\n/**\n * Bypasses OpenAI's use of Cloudflare to get the cookies required to use\n * ChatGPT. Uses Puppeteer with a stealth plugin under the hood.\n *\n * If you pass `email` and `password`, then it will log into the account and\n * include a `sessionToken` in the response.\n *\n * If you don't pass `email` and `password`, then it will just return a valid\n * `clearanceToken`.\n *\n * This can be useful because `clearanceToken` expires after ~2 hours, whereas\n * `sessionToken` generally lasts much longer. We recommend renewing your\n * `clearanceToken` every hour or so and creating a new instance of `ChatGPTAPI`\n * with your updated credentials.\n */\nexport async function getOpenAIAuth({\n  email,\n  password,\n  browser,\n  page,\n  timeoutMs = 2 * 60 * 1000,\n  isGoogleLogin = false,\n  isMicrosoftLogin = false,\n  captchaToken = process.env.CAPTCHA_TOKEN,\n  nopechaKey = process.env.NOPECHA_KEY,\n  executablePath,\n  proxyServer = process.env.PROXY_SERVER\n}: {\n  email?: string\n  password?: string\n  browser?: Browser\n  page?: Page\n  timeoutMs?: number\n  isGoogleLogin?: boolean\n  isMicrosoftLogin?: boolean\n  captchaToken?: string\n  nopechaKey?: string\n  executablePath?: string\n  proxyServer?: string\n}): Promise<OpenAIAuth> {\n  const origBrowser = browser\n  const origPage = page\n\n  try {\n    if (!browser) {\n      browser = await getBrowser({\n        captchaToken,\n        nopechaKey,\n        executablePath,\n        proxyServer\n      })\n    }\n\n    const userAgent = await browser.userAgent()\n    if (!page) {\n      page = (await browser.pages())[0] || (await browser.newPage())\n      page.setDefaultTimeout(timeoutMs)\n    }\n\n    await page.goto('https://chat.openai.com/auth/login', {\n      waitUntil: 'networkidle2'\n    })\n\n    // NOTE: this is where you may encounter a CAPTCHA\n    await checkForChatGPTAtCapacity(page, { timeoutMs })\n\n    if (hasRecaptchaPlugin) {\n      const captchas = await page.findRecaptchas()\n\n      if (captchas?.filtered?.length) {\n        console.log('solving captchas using 2captcha...')\n        const res = await page.solveRecaptchas()\n        console.log('captcha result', res)\n      }\n    }\n\n    // once we get to this point, the Cloudflare cookies should be available\n\n    // login as well (optional)\n    if (email && password) {\n      await waitForConditionOrAtCapacity(page, () =>\n        page.waitForSelector('#__next .btn-primary', { timeout: timeoutMs })\n      )\n      await delay(500)\n\n      // click login button and wait for navigation to finish\n      await Promise.all([\n        page.waitForNavigation({\n          waitUntil: 'networkidle2',\n          timeout: timeoutMs\n        }),\n\n        page.click('#__next .btn-primary')\n      ])\n\n      await checkForChatGPTAtCapacity(page, { timeoutMs })\n\n      let submitP: () => Promise<void>\n\n      if (isGoogleLogin) {\n        await page.click('button[data-provider=\"google\"]')\n        await page.waitForSelector('input[type=\"email\"]')\n        await page.type('input[type=\"email\"]', email, { delay: 10 })\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await page.waitForSelector('input[type=\"password\"]', { visible: true })\n        await page.type('input[type=\"password\"]', password, { delay: 10 })\n        submitP = () => page.keyboard.press('Enter')\n      } else if (isMicrosoftLogin) {\n        await page.click('button[data-provider=\"windowslive\"]')\n        await page.waitForSelector('input[type=\"email\"]')\n        await page.type('input[type=\"email\"]', email, { delay: 10 })\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await delay(1500)\n        await page.waitForSelector('input[type=\"password\"]', { visible: true })\n        await page.type('input[type=\"password\"]', password, { delay: 10 })\n        submitP = () => page.keyboard.press('Enter')\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await delay(1000)\n      } else {\n        await page.waitForSelector('#username')\n        await page.type('#username', email, { delay: 20 })\n        await delay(100)\n\n        // NOTE: this is where you may encounter a CAPTCHA\n        if (hasNopechaExtension) {\n          await waitForRecaptcha(page, { timeoutMs })\n        } else if (hasRecaptchaPlugin) {\n          console.log('solving captchas using 2captcha...')\n          const res = await page.solveRecaptchas()\n          if (res.captchas?.length) {\n            console.log('captchas result', res)\n          } else {\n            console.log('no captchas found')\n          }\n        }\n\n        await delay(1200)\n        const frame = page.mainFrame()\n        const submit = await page.waitForSelector('button[type=\"submit\"]', {\n          timeout: timeoutMs\n        })\n        frame.focus('button[type=\"submit\"]')\n        await submit.focus()\n        await submit.click()\n        await page.waitForSelector('#password', { timeout: timeoutMs })\n        await page.type('#password', password, { delay: 10 })\n        submitP = () => page.click('button[type=\"submit\"]')\n      }\n\n      await Promise.all([\n        waitForConditionOrAtCapacity(page, () =>\n          page.waitForNavigation({\n            waitUntil: 'networkidle2',\n            timeout: timeoutMs\n          })\n        ),\n        submitP()\n      ])\n    } else {\n      await delay(2000)\n      await checkForChatGPTAtCapacity(page, { timeoutMs })\n    }\n\n    const pageCookies = await page.cookies()\n    const cookies = pageCookies.reduce(\n      (map, cookie) => ({ ...map, [cookie.name]: cookie }),\n      {}\n    )\n\n    const authInfo: OpenAIAuth = {\n      userAgent,\n      clearanceToken: cookies['cf_clearance']?.value,\n      sessionToken: cookies['__Secure-next-auth.session-token']?.value,\n      cookies\n    }\n\n    return authInfo\n  } catch (err) {\n    throw err\n  } finally {\n    if (origBrowser) {\n      if (page && page !== origPage) {\n        await page.close()\n      }\n    } else if (browser) {\n      await browser.close()\n    }\n\n    page = null\n    browser = null\n  }\n}\n\n/**\n * Launches a non-puppeteer instance of Chrome. Note that in my testing, I wasn't\n * able to use the built-in `puppeteer` version of Chromium because Cloudflare\n * recognizes it and blocks access.\n */\nexport async function getBrowser(\n  opts: PuppeteerLaunchOptions & {\n    captchaToken?: string\n    nopechaKey?: string\n    proxyServer?: string\n  } = {}\n) {\n  const {\n    captchaToken = process.env.CAPTCHA_TOKEN,\n    nopechaKey = process.env.NOPECHA_KEY,\n    executablePath = defaultChromeExecutablePath(),\n    proxyServer = process.env.PROXY_SERVER,\n    ...launchOptions\n  } = opts\n\n  if (captchaToken && !hasRecaptchaPlugin) {\n    hasRecaptchaPlugin = true\n    // console.log('use captcha', captchaToken)\n\n    puppeteer.use(\n      RecaptchaPlugin({\n        provider: {\n          id: '2captcha',\n          token: captchaToken\n        },\n        visualFeedback: true // colorize reCAPTCHAs (violet = detected, green = solved)\n      })\n    )\n  }\n\n  const puppeteerArgs = [\n    '--no-sandbox',\n    '--disable-setuid-sandbox',\n    '--disable-infobars',\n    '--disable-dev-shm-usage',\n    '--disable-blink-features=AutomationControlled',\n    '--ignore-certificate-errors',\n    '--no-first-run',\n    '--no-service-autorun',\n    '--password-store=basic',\n    '--system-developer-mode',\n    // the following flags all try to reduce memory\n    // '--single-process',\n    '--mute-audio',\n    '--disable-default-apps',\n    '--no-zygote',\n    '--disable-accelerated-2d-canvas',\n    '--disable-web-security',\n    '--disable-gpu'\n    // '--js-flags=\"--max-old-space-size=1024\"'\n  ]\n\n  if (nopechaKey) {\n    const nopechaPath = path.join(\n      __dirname,\n      '..',\n      'third-party',\n      'nopecha-chrome-extension'\n    )\n    puppeteerArgs.push(`--disable-extensions-except=${nopechaPath}`)\n    puppeteerArgs.push(`--load-extension=${nopechaPath}`)\n    hasNopechaExtension = true\n  }\n\n  if (proxyServer) {\n    puppeteerArgs.push(`--proxy-server=${proxyServer}`)\n  }\n\n  const browser = await puppeteer.launch({\n    headless: false,\n    // https://peter.sh/experiments/chromium-command-line-switches/\n    args: puppeteerArgs,\n    ignoreDefaultArgs: [\n      '--disable-extensions',\n      '--enable-automation',\n      '--disable-component-extensions-with-background-pages'\n    ],\n    ignoreHTTPSErrors: true,\n    executablePath,\n    ...launchOptions\n  })\n\n  if (process.env.PROXY_VALIDATE_IP) {\n    const page = (await browser.pages())[0] || (await browser.newPage())\n    // send a fetch request to https://ifconfig.co using page.evaluate() and verify the IP matches\n    let ip\n    try {\n      ;({ ip } = await page.evaluate(() => {\n        return fetch('https://ifconfig.co', {\n          headers: {\n            Accept: 'application/json'\n          }\n        }).then((res) => res.json())\n      }))\n    } catch (err) {\n      throw new Error(`Proxy IP validation failed: ${err.message}`)\n    }\n    if (ip !== process.env.PROXY_VALIDATE_IP) {\n      throw new Error(\n        `Proxy IP mismatch: ${ip} !== ${process.env.PROXY_VALIDATE_IP}`\n      )\n    }\n  }\n\n  // TOdO: this is a really hackity hack way of setting the API key...\n  if (hasNopechaExtension) {\n    const page = (await browser.pages())[0] || (await browser.newPage())\n    await page.goto(`https://nopecha.com/setup#${nopechaKey}`)\n    await delay(1000)\n    try {\n      const page3 = await browser.newPage()\n      await page.close()\n\n      // find the nopecha extension ID\n      const targets = browser.targets()\n      const extensionIds = (\n        await Promise.all(\n          targets.map(async (target) => {\n            if (target.type() !== 'service_worker') {\n              return\n            }\n\n            // const titleL = title?.toLowerCase()\n            // if (titleL?.includes('nopecha'))\n            const url = new URL(target.url())\n            return url.hostname\n          })\n        )\n      ).filter(Boolean)\n      const extensionId = extensionIds[0]\n\n      if (extensionId) {\n        const extensionUrl = `chrome-extension://${extensionId}/popup.html`\n        await page3.goto(extensionUrl, { waitUntil: 'networkidle2' })\n        await delay(500)\n\n        const editKey = await page3.waitForSelector('#edit_key .clickable')\n        await editKey.click()\n\n        const settingsInput = await page3.waitForSelector('input.settings_text')\n        // console.log('value1', await settingsInput.evaluate((el) => el.value))\n\n        await settingsInput.evaluate((el) => {\n          el.value = ''\n        })\n        await settingsInput.type(nopechaKey)\n\n        // console.log('value2', await settingsInput.evaluate((el) => el.value))\n        await settingsInput.evaluate((el, value) => {\n          el.value = value\n        }, nopechaKey)\n\n        // console.log('value3', await settingsInput.evaluate((el) => el.value))\n        await settingsInput.press('Enter')\n        await delay(500)\n        await editKey.click()\n        await delay(2000)\n        console.log('initialized nopecha extension with key', nopechaKey)\n      } else {\n        console.error(\n          \"error initializing nopecha extension; couldn't determine extension ID\"\n        )\n      }\n    } catch (err) {\n      console.error('error initializing nopecha extension', err)\n    }\n  }\n\n  return browser\n}\n\n/**\n * Gets the default path to chrome's executable for the current platform.\n */\nexport const defaultChromeExecutablePath = (): string => {\n  if (process.env.PUPPETEER_EXECUTABLE_PATH) {\n    return process.env.PUPPETEER_EXECUTABLE_PATH\n  }\n\n  switch (os.platform()) {\n    case 'win32':\n      return 'C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe'\n\n    case 'darwin':\n      return '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'\n\n    default: {\n      /**\n       * Since two (2) separate chrome releases exist on linux, we first do a\n       * check to ensure we're executing the right one.\n       */\n      const chromeExists = fs.existsSync('/usr/bin/google-chrome')\n\n      return chromeExists\n        ? '/usr/bin/google-chrome'\n        : '/usr/bin/google-chrome-stable'\n    }\n  }\n}\n\nasync function checkForChatGPTAtCapacity(\n  page: Page,\n  opts: {\n    timeoutMs?: number\n    pollingIntervalMs?: number\n    retries?: number\n  } = {}\n) {\n  const {\n    timeoutMs = 2 * 60 * 1000, // 2 minutes\n    pollingIntervalMs = 3000,\n    retries = 10\n  } = opts\n\n  // console.log('checkForChatGPTAtCapacity', page.url())\n  let isAtCapacity = false\n  let numTries = 0\n\n  do {\n    try {\n      await solveSimpleCaptchas(page)\n\n      const res = await page.$x(\"//div[contains(., 'ChatGPT is at capacity')]\")\n      isAtCapacity = !!res?.length\n\n      if (isAtCapacity) {\n        if (++numTries >= retries) {\n          break\n        }\n\n        // try refreshing the page if chatgpt is at capacity\n        await page.reload({\n          waitUntil: 'networkidle2',\n          timeout: timeoutMs\n        })\n\n        await delay(pollingIntervalMs)\n      }\n    } catch (err) {\n      // ignore errors likely due to navigation\n      ++numTries\n      break\n    }\n  } while (isAtCapacity)\n\n  if (isAtCapacity) {\n    const error = new types.ChatGPTError('ChatGPT is at capacity')\n    error.statusCode = 503\n    throw error\n  }\n}\n\nasync function waitForConditionOrAtCapacity(\n  page: Page,\n  condition: () => Promise<any>,\n  opts: {\n    pollingIntervalMs?: number\n  } = {}\n) {\n  const { pollingIntervalMs = 500 } = opts\n\n  return new Promise<void>((resolve, reject) => {\n    let resolved = false\n\n    async function waitForCapacityText() {\n      if (resolved) {\n        return\n      }\n\n      try {\n        await checkForChatGPTAtCapacity(page)\n\n        if (!resolved) {\n          setTimeout(waitForCapacityText, pollingIntervalMs)\n        }\n      } catch (err) {\n        if (!resolved) {\n          resolved = true\n          return reject(err)\n        }\n      }\n    }\n\n    condition()\n      .then(() => {\n        if (!resolved) {\n          resolved = true\n          resolve()\n        }\n      })\n      .catch((err) => {\n        if (!resolved) {\n          resolved = true\n          reject(err)\n        }\n      })\n\n    setTimeout(waitForCapacityText, pollingIntervalMs)\n  })\n}\n\nasync function solveSimpleCaptchas(page: Page) {\n  try {\n    const verifyYouAreHuman = await page.$('text=Verify you are human')\n    if (verifyYouAreHuman) {\n      await delay(2000)\n      await verifyYouAreHuman.click({\n        delay: random.int(5, 25)\n      })\n      await delay(1000)\n    }\n\n    const cloudflareButton = await page.$('.hcaptcha-box')\n    if (cloudflareButton) {\n      await delay(2000)\n      await cloudflareButton.click({\n        delay: random.int(5, 25)\n      })\n      await delay(1000)\n    }\n  } catch (err) {\n    // ignore errors\n  }\n}\n\nasync function waitForRecaptcha(\n  page: Page,\n  opts: {\n    pollingIntervalMs?: number\n    timeoutMs?: number\n  } = {}\n) {\n  await solveSimpleCaptchas(page)\n\n  if (!hasNopechaExtension) {\n    return\n  }\n\n  const { pollingIntervalMs = 100, timeoutMs } = opts\n  const captcha = await page.$('textarea#g-recaptcha-response')\n  const startTime = Date.now()\n\n  if (captcha) {\n    console.log('waiting to solve recaptcha...')\n\n    do {\n      const value = (await captcha.evaluate((el) => el.value))?.trim()\n      if (value?.length) {\n        // recaptcha has been solved!\n        break\n      }\n\n      if (timeoutMs) {\n        const now = Date.now()\n        if (now - startTime >= timeoutMs) {\n          throw new TimeoutError('Timed out waiting to solve Recaptcha')\n        }\n      }\n\n      await delay(pollingIntervalMs)\n    } while (true)\n  }\n}\n"],"mappings":"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","names":["fetch","url","fetch","url","TimeoutError","_a","_b","_c","_d","createParser","streamAsyncIterable","pTimeout","url","message","fetch","delay","uuidv4","__dirname","url","url","delay","uuidv4"]}